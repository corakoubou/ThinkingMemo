<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>思考メモ帳（保存＋スマホ最適化＋コイン/ボール演出）</title>
  <style>
    * { box-sizing: border-box; }

    body{
      margin:0; padding:0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:#1f2933; color:#f9fafb;
      display:flex; justify-content:center; align-items:flex-start;
      min-height:100vh;
    }

    .container{
      margin:40px 16px;
      background:#111827;
      border-radius:16px;
      padding:20px;
      max-width:800px;
      width:100%;
      box-shadow:0 15px 35px rgba(0,0,0,0.5);
      position:relative;
      overflow:visible;
    }

    h1{ margin:0 0 16px; font-size:1.6rem; text-align:center; }

    .controls{
      display:flex; gap:8px; margin-bottom:12px;
      flex-wrap:wrap; justify-content:center; align-items:center;
    }

    button{
      border:none; border-radius:999px;
      padding:8px 18px;
      font-size:0.95rem;
      cursor:pointer;
      font-weight:600;
      transition:transform .1s ease, box-shadow .1s ease, opacity .2s ease;
      touch-action: manipulation;
    }
    button:disabled{ opacity:.4; cursor:not-allowed; box-shadow:none; transform:none; }
    #startBtn{ background:#10b981; color:#022c22; }
    #stopBtn{ background:#f97316; color:#7c2d12; }
    #resetBtn{ background:#6b7280; color:#e5e7eb; }
    button:not(:disabled):hover{
      transform:translateY(-1px);
      box-shadow:0 4px 10px rgba(0,0,0,.35);
    }

    .select-pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border:1px solid #374151;
      border-radius:999px;
      background:#0b1220;
      user-select:none;
      font-size:.9rem;
      color:#e5e7eb;
    }
    .select-pill select{
      background:transparent;
      border:none;
      outline:none;
      color:#e5e7eb;
      font-size:.9rem;
      cursor:pointer;
    }
    .select-pill option{ color:#111827; }

    .info{
      display:flex; flex-wrap:wrap; gap:16px;
      margin-bottom:12px;
      justify-content:center;
      font-size:.95rem;
    }
    .info-item{
      background:#111827;
      border-radius:10px;
      padding:6px 10px;
      border:1px solid #374151;
      min-width:160px;
      text-align:center;
      position:relative;
      z-index:2;
    }
    .label{ font-size:.8rem; color:#9ca3af; margin-bottom:2px; }
    .value{ font-size:1.1rem; font-variant-numeric: tabular-nums; }

    #memo{
      width:100%;
      height:280px;
      background:#020617;
      color:#f9fafb;
      border-radius:12px;
      border:1px solid #374151;
      padding:10px 12px;
      resize:vertical;
      font-size:1rem;
      line-height:1.45;
      position:relative;
      z-index:1;
    }
    #memo:focus{
      outline:none;
      border-color:#10b981;
      box-shadow:0 0 0 1px rgba(16,185,129,.6);
    }

    .note{
      margin-top:6px;
      font-size:.8rem;
      color:#9ca3af;
      text-align:right;
    }

    /* コイン演出レイヤー（DOM） */
    #fxLayer{
      position:absolute;
      inset:0;
      pointer-events:none;
      overflow:visible;
      z-index:3;
    }
    .coin{
      position:absolute;
      width:16px; height:16px;
      border-radius:50%;
      background: radial-gradient(circle at 35% 35%, #fff7cc 0%, #fbbf24 35%, #b45309 100%);
      box-shadow: 0 6px 14px rgba(0,0,0,0.35);
      transform: translate(-50%, -50%);
      opacity:0;
      will-change: transform, opacity;
    }

    /* ボール演出はCanvas */
    #ballCanvas{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index:2;
      display:none;
    }

    /* ===== スマホ最適化 ===== */
    @media (max-width: 600px){
      .container{
        margin:8px;
        padding:12px;
        border-radius:12px;
      }
      h1{ font-size:1.25rem; margin-bottom:12px; }
      .controls{ gap:6px; }
      button{
        padding:10px 14px;
        font-size:0.92rem;
      }
      .info{ gap:8px; }
      .info-item{
        min-width:140px;
        padding:8px 8px;
      }
      #memo{
        height:45vh;
        resize:none;
      }
      .note{ text-align:left; }
    }

    @media (prefers-reduced-motion: reduce){
      .coin{ display:none; }
      #ballCanvas{ display:none !important; }
    }
  </style>
</head>
<body>
<div class="container" id="container">
  <h1>思考メモ帳（保存＋演出）</h1>

  <div class="controls">
    <button id="startBtn">思考開始</button>
    <button id="stopBtn" disabled>思考停止</button>
    <button id="resetBtn">リセット</button>

    <label class="select-pill" title="演出タイプっす">
      演出
      <select id="fxMode">
        <option value="off">OFF</option>
        <option value="coin" selected>コイン</option>
        <option value="ball">ボール(物理)</option>
      </select>
    </label>
  </div>

  <div class="info">
    <div class="info-item">
      <div class="label">思考時間</div>
      <div class="value" id="timeDisplay">00:00:00</div>
    </div>
    <div class="info-item">
      <div class="label">評価ポイント</div>
      <div class="value" id="scoreDisplay">0.0</div>
    </div>
  </div>

  <textarea id="memo" placeholder="ここに思考内容やメモを書いてくださいっす、ご主人。&#10;・打鍵1回ごとに +1.5点（長押しリピート除外）っす&#10;・0.1秒ごとに -0.1点（＝1秒で -1点）っす&#10;・リロードしても内容は保存されるっす"></textarea>

  <div class="note">
    ルール：0.1秒ごとに -0.1点（＝1秒で -1点） / 打鍵1回ごとに +1.5点（長押しリピート除外）っす
  </div>

  <canvas id="ballCanvas"></canvas>
  <div id="fxLayer"></div>
</div>

<script>
  const container    = document.getElementById("container");
  const fxLayer      = document.getElementById("fxLayer");
  const fxMode       = document.getElementById("fxMode");

  const startBtn     = document.getElementById("startBtn");
  const stopBtn      = document.getElementById("stopBtn");
  const resetBtn     = document.getElementById("resetBtn");
  const timeDisplay  = document.getElementById("timeDisplay");
  const scoreDisplay = document.getElementById("scoreDisplay");
  const memo         = document.getElementById("memo");

  const ballCanvas   = document.getElementById("ballCanvas");
  const ballCtx      = ballCanvas.getContext("2d");

  // ===== 永続化（localStorage）=====
  const STORAGE_KEY = "thinking_memo_state_v2";

  function saveState(){
    const state = {
      memo: memo.value,
      elapsedSeconds: getTotalSecondsNow(), // 実行中でも現在値を保存
      keyCount,
      fxMode: fxMode.value
    };
    try{
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }catch(e){
      console.warn("保存に失敗したっす（容量オーバー等）", e);
    }
  }

  function loadState(){
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    try{
      const state = JSON.parse(raw);
      memo.value = state.memo ?? "";
      elapsedSeconds = Number(state.elapsedSeconds ?? 0) || 0;
      keyCount = Number(state.keyCount ?? 0) || 0;
      if (state.fxMode) fxMode.value = state.fxMode;
    }catch(e){
      console.warn("保存データの読み込みに失敗したっす", e);
    }
  }

  // ===== タイマー/スコア =====
  let startTime = null;
  let elapsedSeconds = 0;
  let timerId = null;

  let keyCount = 0;

  // 長押し除外
  const pressedKeys = new Set();

  function formatTime(totalSeconds){
    const sec = Math.max(0, Math.floor(totalSeconds));
    const h = String(Math.floor(sec / 3600)).padStart(2, "0");
    const m = String(Math.floor((sec % 3600) / 60)).padStart(2, "0");
    const s = String(sec % 60).padStart(2, "0");
    return `${h}:${m}:${s}`;
  }

  function calcScore(totalSeconds){
    return keyCount * 1.5 - totalSeconds;
  }

  function getTotalSecondsNow(){
    let total = elapsedSeconds;
    if (startTime !== null){
      total = elapsedSeconds + (Date.now() - startTime) / 1000;
    }
    return total;
  }

  function updateTimeAndScore(){
    const total = getTotalSecondsNow();
    timeDisplay.textContent = formatTime(total);
    scoreDisplay.textContent = calcScore(total).toFixed(1);
  }

  // ===== ボタン =====
  startBtn.addEventListener("click", () => {
    if (startTime !== null) return;
    startTime = Date.now();

    if (timerId === null){
      timerId = setInterval(updateTimeAndScore, 100);
    }

    startBtn.disabled = true;
    stopBtn.disabled = false;
  });

  stopBtn.addEventListener("click", () => {
    if (startTime === null) return;

    elapsedSeconds += (Date.now() - startTime) / 1000;
    startTime = null;

    if (timerId !== null){
      clearInterval(timerId);
      timerId = null;
    }

    updateTimeAndScore();
    saveState();

    startBtn.disabled = false;
    stopBtn.disabled = true;
  });

  resetBtn.addEventListener("click", () => {
    if (timerId !== null){
      clearInterval(timerId);
      timerId = null;
    }
    startTime = null;
    elapsedSeconds = 0;
    keyCount = 0;
    pressedKeys.clear();

    memo.value = "";
    updateTimeAndScore();

    // 演出リセット
    fxLayer.innerHTML = "";
    liveCoins = 0;
    resetBall();

    // 保存データも消す
    localStorage.removeItem(STORAGE_KEY);

    startBtn.disabled = false;
    stopBtn.disabled = true;
  });

  // ===== コイン演出 =====
  const MAX_COINS = 80;
  let liveCoins = 0;

  function spawnCoinToScore(){
    if (fxMode.value !== "coin") return;
    if (window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;
    if (liveCoins >= MAX_COINS) return;
    liveCoins++;

    const cRect = container.getBoundingClientRect();
    const mRect = memo.getBoundingClientRect();
    const sRect = scoreDisplay.getBoundingClientRect();
    const toLocal = (x,y)=>({ x:x-cRect.left, y:y-cRect.top });

    const target = toLocal(sRect.left + sRect.width/2, sRect.top + sRect.height/2);

    const padding = 18;
    const edge = Math.floor(Math.random()*4);
    let sx, sy;

    if (edge===0){ sx=mRect.left+Math.random()*mRect.width; sy=mRect.top-padding-Math.random()*24; }
    else if (edge===1){ sx=mRect.right+padding+Math.random()*24; sy=mRect.top+Math.random()*mRect.height; }
    else if (edge===2){ sx=mRect.left+Math.random()*mRect.width; sy=mRect.bottom+padding+Math.random()*24; }
    else { sx=mRect.left-padding-Math.random()*24; sy=mRect.top+Math.random()*mRect.height; }

    const start = toLocal(sx, sy);

    const coin = document.createElement("div");
    coin.className = "coin";
    fxLayer.appendChild(coin);
    coin.style.left = `${start.x}px`;
    coin.style.top  = `${start.y}px`;

    const duration = 420 + Math.random()*220;
    const fadeTail = 120;

    const anim = coin.animate([
      { transform:"translate(-50%,-50%) scale(0.8)", opacity:0.0 },
      { transform:"translate(-50%,-50%) scale(1.0)", opacity:1.0, offset:0.15 },
      { transform:`translate(calc(-50% + ${target.x-start.x}px), calc(-50% + ${target.y-start.y}px)) scale(0.95)`, opacity:1.0, offset:0.85 },
      { transform:`translate(calc(-50% + ${target.x-start.x}px), calc(-50% + ${target.y-start.y}px)) scale(0.7)`, opacity:0.0 }
    ], { duration: duration + fadeTail, easing:"linear", fill:"forwards" });

    anim.onfinish = ()=>{ coin.remove(); liveCoins = Math.max(0, liveCoins-1); };
  }

  // ===== ボール（直進寄り：ランダムは跳ね返りだけ）=====
  let rafId = null;
  let lastTs = null;
  let lastKeyTime = performance.now();

  const ball = { x:100, y:100, vx:200, vy:140, r:12 };

  function resizeCanvas(){
    const rect = container.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    ballCanvas.width  = Math.floor(rect.width * dpr);
    ballCanvas.height = Math.floor(rect.height * dpr);
    ballCanvas.style.width = rect.width + "px";
    ballCanvas.style.height = rect.height + "px";
    ballCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function rand(min,max){ return min + Math.random()*(max-min); }

  function resetBall(){
    resizeCanvas();
    const w = ballCanvas.clientWidth || container.clientWidth;
    const h = ballCanvas.clientHeight || container.clientHeight;

    ball.x = w * 0.5;
    ball.y = h * 0.65;
    ball.r = 12;

    const sp = 220;
    const ang = rand(0, Math.PI*2);
    ball.vx = Math.cos(ang)*sp;
    ball.vy = Math.sin(ang)*sp;

    lastKeyTime = performance.now();
    drawBallFrame();
  }

  function ballImpulseOnKey(){
    const mult = 1.12; // 方向は変えずに速度だけUP
    ball.vx *= mult;
    ball.vy *= mult;

    const maxSpeed = 1200;
    const sp = Math.hypot(ball.vx, ball.vy);
    if (sp > maxSpeed){
      const s = maxSpeed / sp;
      ball.vx *= s; ball.vy *= s;
    }
    lastKeyTime = performance.now();
  }

  function applyBounceRandomOnlyInBounce(){
    const sp = Math.max(60, Math.hypot(ball.vx, ball.vy));
    let ang = Math.atan2(ball.vy, ball.vx);
    ang += rand(-0.22, 0.22); // 跳ね返りの揺らしだけ
    ball.vx = Math.cos(ang) * sp;
    ball.vy = Math.sin(ang) * sp;
  }

  function physicsStep(dt){
    const w = ballCanvas.clientWidth || container.clientWidth;
    const h = ballCanvas.clientHeight || container.clientHeight;

    // 打鍵しないと減速（アイドルが長いほど強め）
    const now = performance.now();
    const idle = Math.max(0, (now - lastKeyTime) / 1000);

    const base = 0.994;
    const extra = Math.max(0, 1 - idle * 0.25);
    const friction = Math.max(0.92, base * (0.95 + 0.05 * extra));
    const f = Math.pow(friction, dt * 60);

    ball.vx *= f; ball.vy *= f;

    // 完全停止防止（方向維持）
    const minSpeed = 14;
    let sp = Math.hypot(ball.vx, ball.vy);
    if (sp < minSpeed){
      const ang = Math.atan2(ball.vy, ball.vx);
      ball.vx = Math.cos(ang) * minSpeed;
      ball.vy = Math.sin(ang) * minSpeed;
    }

    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    let hit = false;

    if (ball.x - ball.r < 0){
      ball.x = ball.r;
      ball.vx = Math.abs(ball.vx);
      hit = true;
    } else if (ball.x + ball.r > w){
      ball.x = w - ball.r;
      ball.vx = -Math.abs(ball.vx);
      hit = true;
    }

    if (ball.y - ball.r < 0){
      ball.y = ball.r;
      ball.vy = Math.abs(ball.vy);
      hit = true;
    } else if (ball.y + ball.r > h){
      ball.y = h - ball.r;
      ball.vy = -Math.abs(ball.vy);
      hit = true;
    }

    if (hit) applyBounceRandomOnlyInBounce();
  }

  function drawBallFrame(){
    const w = ballCanvas.clientWidth || container.clientWidth;
    const h = ballCanvas.clientHeight || container.clientHeight;
    ballCtx.clearRect(0,0,w,h);

    const g = ballCtx.createRadialGradient(
      ball.x - ball.r*0.3, ball.y - ball.r*0.3, ball.r*0.2,
      ball.x, ball.y, ball.r
    );
    g.addColorStop(0, "rgba(240, 253, 250, 0.95)");
    g.addColorStop(0.5, "rgba(16, 185, 129, 0.85)");
    g.addColorStop(1, "rgba(2, 132, 199, 0.85)");

    ballCtx.beginPath();
    ballCtx.fillStyle = g;
    ballCtx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ballCtx.fill();

    ballCtx.beginPath();
    ballCtx.strokeStyle = "rgba(0,0,0,0.35)";
    ballCtx.lineWidth = 2;
    ballCtx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ballCtx.stroke();
  }

  function ballLoop(ts){
    if (fxMode.value !== "ball"){
      rafId = null; lastTs = null;
      return;
    }
    if (lastTs == null) lastTs = ts;
    let dt = (ts - lastTs) / 1000;
    lastTs = ts;

    dt = Math.min(dt, 0.033);

    physicsStep(dt);
    drawBallFrame();
    rafId = requestAnimationFrame(ballLoop);
  }

  function ensureBallRunning(){
    if (fxMode.value !== "ball") return;
    resizeCanvas();
    ballCanvas.style.display = "block";
    if (rafId == null) rafId = requestAnimationFrame(ballLoop);
  }

  function stopBall(){
    ballCanvas.style.display = "none";
    if (rafId != null){ cancelAnimationFrame(rafId); rafId = null; }
    lastTs = null;
    ballCtx.clearRect(0,0,ballCanvas.clientWidth, ballCanvas.clientHeight);
  }

  function applyFxMode(){
    fxLayer.innerHTML = "";
    liveCoins = 0;

    if (fxMode.value === "off"){
      stopBall();
    } else if (fxMode.value === "coin"){
      stopBall();
    } else if (fxMode.value === "ball"){
      fxLayer.innerHTML = "";
      resetBall();
      ensureBallRunning();
    }
    saveState();
  }

  fxMode.addEventListener("change", applyFxMode);
  window.addEventListener("resize", () => {
    if (fxMode.value === "ball") resizeCanvas();
  });

  // ===== 入力（長押しリピート除外）=====
  memo.addEventListener("keydown", (e) => {
    if (!pressedKeys.has(e.code)){
      pressedKeys.add(e.code);

      keyCount++;
      updateTimeAndScore();

      if (fxMode.value === "coin") spawnCoinToScore();
      if (fxMode.value === "ball"){
        ensureBallRunning();
        ballImpulseOnKey();
      }

      saveState();
    }
  });

  memo.addEventListener("keyup", (e) => pressedKeys.delete(e.code));
  memo.addEventListener("blur", () => pressedKeys.clear());

  memo.addEventListener("input", () => {
    updateTimeAndScore();
    saveState();
  });

  // タイマー中も定期保存（500ms）
  let lastAutoSave = performance.now();
  function autoSaveTick(){
    if (startTime !== null){
      const now = performance.now();
      if (now - lastAutoSave >= 500){
        lastAutoSave = now;
        saveState();
      }
    }
    requestAnimationFrame(autoSaveTick);
  }
  requestAnimationFrame(autoSaveTick);

  // ===== 初期化 =====
  loadState();

  // リロード後は「停止状態」で復元（startTimeはnullのまま）
  startBtn.disabled = false;
  stopBtn.disabled = true;

  updateTimeAndScore();
  applyFxMode();
</script>
</body>
</html>
